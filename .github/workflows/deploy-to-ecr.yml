# WatchMe Business API - ECR & EC2 Auto Deployment Workflow
name: Deploy to Amazon ECR and EC2

# Trigger conditions
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

# Environment variables
env:
  AWS_REGION: ap-southeast-2
  ECR_REPOSITORY: watchme-business

# Jobs definition
jobs:
  deploy:
    name: Build and Push to ECR
    runs-on: ubuntu-latest

    steps:
    # Step 1: Checkout code
    - name: Checkout code
      uses: actions/checkout@v4

    # Step 2: Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Step 3: Login to Amazon ECR
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # Step 4: Set up Docker Buildx (multi-platform support)
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # Step 5: Delete old images from ECR (optional but recommended)
    - name: Delete old images from ECR
      run: |
        aws ecr batch-delete-image \
          --region ${{ env.AWS_REGION }} \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=latest || true

    # Step 6: Build, tag, and push image to Amazon ECR (ARM64)
    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd backend
        docker buildx build \
          --platform linux/arm64 \
          --no-cache \
          --push \
          -f Dockerfile.prod \
          -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG \
          -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest \
          .

        echo "‚úÖ Image pushed to ECR:"
        echo "  - $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        echo "  - $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:latest"

    # Step 7: Deploy success notification
    - name: Deploy Success Notification
      if: success()
      run: |
        echo "üéâ Deployment to ECR succeeded!"
        echo "üì¶ Repository: ${{ env.ECR_REPOSITORY }}"
        echo "üè∑Ô∏è Image Tag: ${{ github.sha }}"
        echo "üìç Region: ${{ env.AWS_REGION }}"
        echo ""
        echo "üìã Next Steps:"
        echo "1. SSH to EC2: ssh -i ~/watchme-key.pem ubuntu@3.24.16.82"
        echo "2. Deploy: cd /home/ubuntu/watchme-business-api && ./run-prod.sh"

    # Step 8: Deploy failure notification
    - name: Deploy Failure Notification
      if: failure()
      run: |
        echo "‚ùå Deployment to ECR failed!"
        echo "Please check the logs above for details."

  # Job 2: CD - Auto deployment to EC2
  deploy-to-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: deploy

    steps:
    # Step 1: Setup SSH Agent
    - name: Setup SSH Agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}

    # Step 2: Checkout code (for config files)
    - name: Checkout code
      uses: actions/checkout@v4

    # Step 3: Add EC2 to known hosts
    - name: Add EC2 to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

    # Step 4: Create application directory on EC2
    - name: Create application directory on EC2 if not exists
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
      run: |
        echo "üìÅ Ensuring application directory exists on EC2..."
        ssh ${EC2_USER}@${EC2_HOST} "mkdir -p /home/ubuntu/watchme-business-api"
        echo "‚úÖ Directory verified/created"

    # Step 5: Update configuration files on EC2
    - name: Update configuration files on EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
      run: |
        echo "üì¶ Updating configuration files on EC2..."
        scp -o StrictHostKeyChecking=no backend/docker-compose.prod.yml ${EC2_USER}@${EC2_HOST}:/home/ubuntu/watchme-business-api/
        scp -o StrictHostKeyChecking=no backend/run-prod.sh ${EC2_USER}@${EC2_HOST}:/home/ubuntu/watchme-business-api/
        ssh ${EC2_USER}@${EC2_HOST} "chmod +x /home/ubuntu/watchme-business-api/run-prod.sh"
        echo "‚úÖ Configuration files updated"

    # Step 6: Create/Update .env file on EC2
    - name: Create/Update .env file on EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ap-southeast-2
        S3_BUCKET: ${{ secrets.S3_BUCKET }}
        SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        API_TOKEN: ${{ secrets.API_TOKEN }}
        DEEPGRAM_API_KEY: ${{ secrets.DEEPGRAM_API_KEY }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        SPEECHMATICS_API_KEY: ${{ secrets.SPEECHMATICS_API_KEY }}
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        LLM_DEFAULT_PROVIDER: ${{ secrets.LLM_DEFAULT_PROVIDER }}
        LLM_DEFAULT_MODEL: ${{ secrets.LLM_DEFAULT_MODEL }}
      run: |
        echo "üìù Creating/Updating .env file on EC2..."

        ssh ${EC2_USER}@${EC2_HOST} << ENDSSH
          cd /home/ubuntu/watchme-business-api
          echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}" > .env
          echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}" >> .env
          echo "AWS_REGION=${AWS_REGION}" >> .env
          echo "S3_BUCKET=${S3_BUCKET}" >> .env
          echo "SUPABASE_URL=${SUPABASE_URL}" >> .env
          echo "SUPABASE_SERVICE_ROLE_KEY=${SUPABASE_SERVICE_ROLE_KEY}" >> .env
          echo "API_TOKEN=${API_TOKEN}" >> .env
          echo "DEEPGRAM_API_KEY=${DEEPGRAM_API_KEY}" >> .env
          echo "OPENAI_API_KEY=${OPENAI_API_KEY}" >> .env
          echo "SPEECHMATICS_API_KEY=${SPEECHMATICS_API_KEY}" >> .env
          echo "GEMINI_API_KEY=${GEMINI_API_KEY}" >> .env
          echo "LLM_DEFAULT_PROVIDER=${LLM_DEFAULT_PROVIDER}" >> .env
          echo "LLM_DEFAULT_MODEL=${LLM_DEFAULT_MODEL}" >> .env
        ENDSSH

        ssh ${EC2_USER}@${EC2_HOST} "echo '‚úÖ .env file created/updated successfully' && wc -l /home/ubuntu/watchme-business-api/.env"

    # Step 7: Deploy to EC2 instance
    - name: Deploy to EC2 instance
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
      run: |
        echo "üöÄ Starting deployment to EC2..."

        ssh ${EC2_USER}@${EC2_HOST} << 'ENDSSH'
          set -e
          echo "üì¶ Navigating to application directory..."
          cd /home/ubuntu/watchme-business-api

          echo "üóëÔ∏è Cleaning up old Docker images..."
          docker-compose -f docker-compose.prod.yml down || true
          docker system prune -a -f

          echo "üîÑ Running deployment script..."
          ./run-prod.sh

          echo "‚úÖ Deployment script completed"

          echo "üìä Checking container status..."
          docker ps | grep watchme-business-api || echo "‚ö†Ô∏è Container not found"

          echo "üè• Running health check..."
          sleep 10
          for i in {1..12}; do
            if curl -f http://localhost:8052/health > /dev/null 2>&1; then
              echo "‚úÖ Health check passed (attempt $i/12)"
              break
            fi
            echo "  Attempt $i/12 failed, retrying in 5 seconds..."
            sleep 5
          done
        ENDSSH

        echo "‚úÖ EC2 deployment completed successfully!"

    # Step 8: Deployment success notification
    - name: Deployment Success Notification
      if: success()
      run: |
        echo "üéâ Full CI/CD pipeline completed successfully!"
        echo "üì¶ Service: watchme-business-api"
        echo "üåê URL: https://api.hey-watch.me/business/"
        echo "üè∑Ô∏è Version: ${{ github.sha }}"

    # Step 9: Deployment failure notification
    - name: Deployment Failure Notification
      if: failure()
      run: |
        echo "‚ùå EC2 deployment failed!"
        echo "Please check the SSH connection and server logs."